{"version":3,"sources":["webpack:///webpack/universalModuleDefinition","webpack:///webpack/bootstrap 99a717df8c13ede0ec17","webpack:///./src/backoff.js","webpack:///./src/index.js"],"names":["randomBetween","min","max","Math","floor","random","Backoff","initialDelayMillis","maxDelayMillis","randomBetweenFunc","_initialDelay","_maxDelay","_nextDelay","_randomBetween","delay","READYSTATE","CONNECTING","OPEN","CLOSING","CLOSED","defaultOptions","debug","initialBackoffDelayMillis","maxBackoffDelayMillis","pingSendFunction","pingIntervalSeconds","pingTimeoutMillis","connectTimeoutMillis","noop","AttemptReconnectEvent","attemptNumber","waitMillis","PersistentWebsocket","url","protocols","options","undefined","onopen","onclose","onmessage","onerror","onbeforereconnect","_url","_protocols","_options","Object","assign","_backoff","_waitingForPong","_manuallyClosed","_hasConnected","_retryCount","_pingTimeoutId","_scheduledReconnectTimeoutId","_websocketConnectionCheckTimeoutId","WebSocket","_debugLog","ws","_createWebsocket","_binaryType","binaryType","_onWebsocketClose","bind","_onWebsocketError","_onWebsocketMessage","_onWebsocketOpen","_websocket","_scheduleWebsocketConnectionCheck","event","wasExpected","_scheduleReconnect","_schedulePing","wasReconnect","target","readyState","_cancelWebsocketConnectionCheck","setTimeout","_checkPingResult","clearTimeout","_sendPing","close","nextDelay","_openWebsocket","_checkWebsocketConnection","message","console","code","reason","_cancelScheduledReconnect","data","send","bufferedAmount","extensions","val"],"mappings":"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","file":"persistentwebsocket.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine(\"persistentwebsocket\", [], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"persistentwebsocket\"] = factory();\n\telse\n\t\troot[\"persistentwebsocket\"] = factory();\n})(this, function() {\nreturn \n\n\n// WEBPACK FOOTER //\n// webpack/universalModuleDefinition"," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId])\n \t\t\treturn installedModules[moduleId].exports;\n\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// identity function for calling harmony imports with the correct context\n \t__webpack_require__.i = function(value) { return value; };\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, {\n \t\t\t\tconfigurable: false,\n \t\t\t\tenumerable: true,\n \t\t\t\tget: getter\n \t\t\t});\n \t\t}\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 1);\n\n\n\n// WEBPACK FOOTER //\n// webpack/bootstrap 99a717df8c13ede0ec17","/**\n * Backoff based on \"Decorrelated jitter\" algorithm on https://www.awsarchitectureblog.com/2015/03/backoff.html\n */\n\nfunction randomBetween(min, max) {\n  return Math.floor(Math.random() * (max - min)) + min\n}\n\nexport default class Backoff {\n  constructor(initialDelayMillis, maxDelayMillis, randomBetweenFunc = randomBetween) {\n    this._initialDelay = initialDelayMillis;\n    this._maxDelay = maxDelayMillis;\n    this._nextDelay = this._initialDelay;\n    this._randomBetween = randomBetweenFunc;\n  }\n\n  reset() {\n    this._nextDelay = this._initialDelay;\n  }\n\n  nextDelay() {\n    const delay = this._nextDelay;\n    this._nextDelay = Math.min(\n      this._maxDelay,\n      this._randomBetween(this._initialDelay, delay * 3),\n    );\n    return delay;\n  }\n}\n\n\n// WEBPACK FOOTER //\n// ./src/backoff.js","/**\n * WHAT NEEDS TO BE DONE\n *\n * Reachability\n * Like, all the logic\n */\n\nimport Backoff from \"./backoff\";\n\nexport const READYSTATE = {\n  CONNECTING: 0,\n  OPEN: 1,\n  CLOSING: 2,\n  CLOSED: 3\n};\n\nconst defaultOptions = {\n  debug: false,\n  initialBackoffDelayMillis: 500,\n  maxBackoffDelayMillis: 90000,\n  pingSendFunction: null, // Function that takes the PersistentWebsocket instance as its only parameter\n  pingIntervalSeconds: 30,\n  pingTimeoutMillis: 2000,\n  connectTimeoutMillis: 3000,\n};\n\nfunction noop() {\n}\n\nexport class AttemptReconnectEvent {\n  constructor(attemptNumber, waitMillis) {\n    this.attemptNumber = attemptNumber;\n    this.waitMillis = waitMillis;\n  }\n}\n\nexport class PersistentWebsocket {\n  constructor(url, protocols, options = {}) {\n    if (typeof(protocols) === \"object\") {\n      options = protocols;\n      protocols = undefined;\n    }\n\n    this.onopen = noop;\n    this.onclose = noop;\n    this.onmessage = noop;\n    this.onerror = noop;\n    this.onbeforereconnect = noop;\n\n    this._url = url;\n    this._protocols = protocols;\n    this._options = Object.assign({}, defaultOptions, options);\n    this._backoff = new Backoff(this._options.initialBackoffDelayMillis, this._options.maxBackoffDelayMillis);\n    this._waitingForPong = false;\n    this._manuallyClosed = false;\n    this._hasConnected = false;\n    this._retryCount = 0;\n\n    this._pingTimeoutId = 0;\n    this._scheduledReconnectTimeoutId = 0;\n    this._websocketConnectionCheckTimeoutId = 0;\n  }\n\n  _createWebsocket(url, protocols) {\n    return new WebSocket(url, protocols);\n  }\n\n  _openWebsocket() {\n    this._debugLog(\"Trying to open websocket\");\n    const ws = this._createWebsocket(this._url, this._protocols);\n    if (this._binaryType) {\n      ws.binaryType = this._binaryType;\n    }\n    ws.onclose = this._onWebsocketClose.bind(this);\n    ws.onerror = this._onWebsocketError.bind(this);\n    ws.onmessage = this._onWebsocketMessage.bind(this);\n    ws.onopen = this._onWebsocketOpen.bind(this);\n    this._websocket = ws;\n\n    this._scheduleWebsocketConnectionCheck();\n  }\n\n  _onWebsocketClose(event) {\n    event.wasExpected = this._manuallyClosed;\n    this.onclose(event);\n    if (!this._manuallyClosed) {\n      this._scheduleReconnect();\n    }\n  }\n\n  _onWebsocketError(event) {\n    this.onerror(event);\n  }\n\n  _onWebsocketMessage(event) {\n    // Any message counts as a \"pong\"\n    this._waitingForPong = false;\n\n    // Reschedule ping so pings only occur when the inbound side of the connection is quiet for ${pingIntervalSeconds}\n    this._schedulePing();\n\n    this.onmessage(event);\n  }\n\n  _onWebsocketOpen(event) {\n    event.wasReconnect = this._hasConnected;\n    this.onopen(event);\n    this._hasConnected = true;\n    this._retryCount = 0;\n\n    if (event.target.readyState == READYSTATE.OPEN) {\n      // Start pings\n      this._schedulePing();\n      this._cancelWebsocketConnectionCheck();\n    }\n  }\n\n  _sendPing() {\n    this._waitingForPong = true;\n    this._options.pingSendFunction(this);\n    setTimeout(this._checkPingResult.bind(this), this._options.pingTimeoutMillis);\n  }\n\n  _schedulePing() {\n    // Always clear out any existing scheduled pings\n    if (this._pingTimeoutId) {\n      clearTimeout(this._pingTimeoutId);\n      this._pingTimeoutId = 0;\n    }\n\n    const {pingSendFunction, pingIntervalSeconds} = this._options;\n    if (pingSendFunction && pingIntervalSeconds) {\n      this._pingTimeoutId = setTimeout(this._sendPing.bind(this), pingIntervalSeconds*1000);\n    }\n  }\n\n  _checkPingResult() {\n    if (this._waitingForPong) {\n      this._websocket.close(4001, \"Closing websocket due to ping failure.\");\n    }\n  }\n\n  _scheduleReconnect() {\n    const waitMillis = this._backoff.nextDelay();\n    this._retryCount++;\n    this._debugLog(`Scheduling websocket reconnect attempt ${this._retryCount} in ${waitMillis}ms`);\n    this.onbeforereconnect(new AttemptReconnectEvent(this._retryCount, waitMillis));\n\n    this._scheduledReconnectTimeoutId = setTimeout(this._openWebsocket.bind(this), waitMillis);\n  }\n\n  _cancelScheduledReconnect() {\n    if (this._scheduledReconnectTimeoutId) {\n      clearTimeout(this._scheduledReconnectTimeoutId);\n      this._scheduledReconnectTimeoutId = 0;\n    }\n  }\n\n  _scheduleWebsocketConnectionCheck() {\n    setTimeout(this._checkWebsocketConnection.bind(this), this._options.connectTimeoutMillis);\n  }\n\n  _cancelWebsocketConnectionCheck() {\n    if (this._websocketConnectionCheckTimeoutId) {\n      clearTimeout(this._websocketConnectionCheckTimeoutId);\n      this._websocketConnectionCheckTimeoutId = 0;\n    }\n  }\n\n  _checkWebsocketConnection() {\n    this._debugLog(`Checking websocket connection. ReadyState is ${this._websocket.readyState}`);\n    if (this._websocket.readyState === READYSTATE.OPEN) {\n      // Start pings\n      this._schedulePing();\n    } else {\n      this._websocket.close(4000, \"Unable to establish websocket connection before the configured connectTimeoutMillis\");\n    }\n  }\n\n  _debugLog(message) {\n    if (this._options.debug) {\n      console.debug(message);\n    }\n  }\n\n  open() {\n    if (this._websocket) {\n      throw \"Websocket has already been opened\"\n    }\n    this._openWebsocket();\n  }\n\n  // Delegated Websocket stuff\n  close(code, reason) {\n    this._manuallyClosed = true;\n    this._cancelScheduledReconnect();\n    this._cancelWebsocketConnectionCheck();\n\n    if (!this._websocket) {\n      throw \"Can't close websocket because it was never opened.\";\n    }\n\n    this._websocket.close(code, reason);\n  }\n\n  send(data) {\n    if (!this._websocket) {\n      throw \"Can't send through websocket because it was never opened.\";\n    }\n    this._websocket.send(data);\n  }\n\n  get readyState() {\n    if (!this._websocket) {\n      throw \"Can't get websocket readyState because it was never opened.\";\n    }\n    return this._websocket.readyState;\n  }\n\n  get url() {\n    return this._url;\n  }\n\n  get bufferedAmount() {\n    if (!this._websocket) {\n      throw \"Can't get websocket bufferedAmount because it was never opened.\";\n    }\n    return this._websocket.bufferedAmount;\n  }\n\n  get extensions() {\n    if (!this._websocket) {\n      throw \"Can't get websocket extensions because it was never opened.\";\n    }\n    return this._websocket.extensions;\n  }\n\n  get binaryType() {\n    return this._binaryType;\n  }\n\n  set binaryType(val) {\n    this._binaryType = val;\n    if (this._websocket) {\n      this._websocket.binaryType = val;\n    }\n  }\n\n  get retryCount() {\n    return this._retryCount;\n  }\n}\n\n\n\n// WEBPACK FOOTER //\n// ./src/index.js"],"sourceRoot":""}